/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package xyz.sathro.factory;

import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
import lombok.extern.log4j.Log4j2;
import org.lwjgl.system.Configuration;
import xyz.sathro.factory.event.EventManager;
import xyz.sathro.factory.test.xpbd.PhysicsController;
import xyz.sathro.factory.util.Timer;
import xyz.sathro.factory.vulkan.renderers.UIRenderer;
import xyz.sathro.factory.vulkan.scene.SceneRenderer;
import xyz.sathro.factory.window.MouseInput;
import xyz.sathro.factory.window.Window;
import xyz.sathro.factory.window.events.GameUpdateEvent;
import xyz.sathro.vulkan.Vulkan;
import xyz.sathro.vulkan.renderer.MainRenderer;

import java.lang.reflect.Field;
import java.util.*;
import java.util.concurrent.ConcurrentMap;

@Log4j2
public class Engine {
	public static final int UPDATES_PER_SECOND = 60;
	public static final double UPS_INV = 1D / UPDATES_PER_SECOND;
	public static final double MS_PER_UPDATE = 1000.0 / UPDATES_PER_SECOND;
	public static final double MS_PER_UPDATE_INV = 1 / MS_PER_UPDATE;

	private static final Queue<Runnable> taskQueue = new LinkedList<>();
	private static final Map<Object, Runnable> waitTaskMap = new Object2ObjectOpenHashMap<>();

	private static final Thread renderThread = new Thread(MainRenderer::renderLoop);
	private static final Thread physicsThread = new Thread(PhysicsController::physicsUpdateLoop);

	public static boolean debugMode = false;

	private static void updateLoop() {
		double lag = 0.0;
		final Timer timer = new Timer();

		while (!Window.shouldClose) {
			synchronized (taskQueue) {
				while (!taskQueue.isEmpty()) {
					taskQueue.poll().run();
				}
			}
			synchronized (waitTaskMap) {
				final Iterator<Map.Entry<Object, Runnable>> iterator = waitTaskMap.entrySet().iterator();
				while (iterator.hasNext()) {
					final Map.Entry<Object, Runnable> entry = iterator.next();

					entry.getValue().run();
					synchronized (entry.getKey()) {
						entry.getKey().notify();
					}

					iterator.remove();
				}
			}
			Window.update();

			lag += timer.getElapsedTimeAndReset();
			if (lag >= MS_PER_UPDATE) {
				EventManager.callEvent(new GameUpdateEvent(lag * MS_PER_UPDATE_INV));

				lag -= MS_PER_UPDATE;
			}
		}
	}

	public static void submitTask(Runnable runnable) {
		synchronized (taskQueue) {
			taskQueue.add(runnable);
		}
	}

	@SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
	public static void submitTaskAndWait(Runnable runnable) {
		final Object sync = new Object();
		synchronized (waitTaskMap) {
			waitTaskMap.put(sync, runnable);
		}
		try {
			synchronized (sync) {
				sync.wait();
			}
		} catch (InterruptedException ignored) { }
	}

	@SuppressWarnings("unchecked")
	public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException, InterruptedException {
		log.info("START");

		if (args.length > 0) {
			debugMode = Boolean.parseBoolean(args[0]);
		}

		if (debugMode) {
			log.info("ENABLED DEBUG MODE");

			Configuration.DEBUG_MEMORY_ALLOCATOR.set(true);
			Configuration.DEBUG_STACK.set(true);
		}

		try {
			Window.init();
			MouseInput.init();
			Vulkan.initVulkan(List.of(SceneRenderer.INSTANCE, UIRenderer.INSTANCE));

			renderThread.setName("render");
			physicsThread.setName("physics");

			renderThread.start();
			physicsThread.start();
			updateLoop();
			renderThread.join();
			physicsThread.join();

			Vulkan.cleanup();
			MouseInput.cleanup();
			Window.cleanup();
		} catch (Throwable e) {
			if (debugMode) {
				// hack to turn off memory leaks print if exception was caught, because they are useless in that scenario
				final Class<?> debugAllocator = Class.forName("org.lwjgl.system.MemoryManage$DebugAllocator");
				final Field allocations = debugAllocator.getDeclaredField("ALLOCATIONS");
				allocations.setAccessible(true);
				((ConcurrentMap<Long, ?>) allocations.get(null)).clear();

				final Class<?> memoryUtilLazyInit = Class.forName("org.lwjgl.system.MemoryUtil$LazyInit");
				final Field allocator = memoryUtilLazyInit.getDeclaredField("ALLOCATOR");
				allocator.setAccessible(true);

				final Field callbacks = debugAllocator.getDeclaredField("callbacks");
				callbacks.setAccessible(true);
				callbacks.set(allocator.get(null), new long[0]);
			}

			throw e;
		}

		log.info("END");
	}
}
